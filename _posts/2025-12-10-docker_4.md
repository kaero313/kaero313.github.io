---
title: "[도커-4] CI/CD 자동화: GitHub Actions를 통한 도커 이미지 빌드와 자동 배포"
date: 2025-12-10 13:49:31 +0900
categories: [Infra, Docker]
tags: [도커, 인프라, 서버]
preview_image: assets/img/docker/prev_icon.png
---

<div align="center">
  <img src="assets/img/docker/github_actions.png" alt="깃허브 액션 아이콘" width="500">
</div>

> 아니 도커 얘기중인데 갑자기 깃허브 관련한게 왜 나옴 ?

도커로 애플리케이션을 깔끔하게 컨테이너화하는 것까진 성공했다. 그런데 문득 궁금증이 생겼다.<br/>
"내가 만든 이 이미지를 코드가 바뀔 때마다 자동으로 빌드하고, 서버에 올리는 과정은 어떻게 해야 할까?"<br/>
결국 도커의 궁극적인 목적, 즉 '어디서든 쉽게 실행되는 애플리케이션'을 완성하려면 자동화 파이프라인 구축이 필수적이었다.<br/>
Jenkins, GitLab CI/CD, CircleCI, GitHub Actions등 수 많은 CI/CD 도구가 있었는데,<br/>
여기서는 GitHub Actions를 사용하여 자동화 파이프라인을 구축해보도록 하겠다.<br/>
<br/>
도커가 결과물(이미지)을 담당한다면, 액션은 과정(빌드, 테스트, 배포)을 책임지는 셈이다.<br/>
최종적인 워크 플로우는 아래와 같이 될 것이다.

```tree
1. 개발자가 로컬에서 코드 수정
   ↓
2. 수정 내역 Git Push
   ↓
3. 자동으로 도커 이미지 빌드
   ↓
4. 도커 허브 업로드
```

# 깃허브
---

## 레포지토리 생성

우선 코드를 올릴 수 있는 레포지토리가 필요하다.<br/>
docker_github-actions 라는 이름으로 생성을 하고, 도커와 연동하기 위해<br/>
도커 허브 엑세스 토큰을 발급받아 유저 이름과 함께 해당 레포지토리 secrets에 등록을 했다.<br/>

<div align="left" style="display:flex;">
  <img src="assets/img/docker/dockerhub_token.png" alt="도커 허브 토큰" width="500">
  <img src="assets/img/docker/repo_secrets.png" alt="레포 시크릿" width="500">
</div>

## 깃허브 액션

깃허브 액션의 워크플로우를 정의하고, 사용하기 위해서 반드시 지켜야 하는 규칙은 두 가지이다.
- 레포지토리 최상단에 필수 디렉토리명 지정하여 생성: .github/workflows
- 해당 디렉토리 안의 파일은 yaml, yml 포맷으로 작성

다음은 .github/workflows/docker-build.yml의 내용이다.
```yml
# ============================================
# Workflow 이름 (GitHub Actions 탭에 표시됨)
# ============================================
name: Docker Build and Push

# ============================================
# 트리거: 언제 이 workflow를 실행할지 정의
# ============================================
on:
  push:
    branches: [ main ]  # main 브랜치에 push 시 실행
    tags:
      - 'v*'           # v로 시작하는 태그 push 시 실행 (예: v1.0, v2.1)

# ============================================
# Jobs: 실행할 작업들
# ============================================
jobs:
  build:
    # Ubuntu 최신 버전 가상 머신에서 실행
    runs-on: ubuntu-latest
    
    # ============================================
    # Steps: 순차적으로 실행할 단계들
    # ============================================
    steps:
      # ----------------------------------------
      # Step 1: GitHub 저장소에서 코드 가져오기
      # ----------------------------------------
      - name: Checkout code
        uses: actions/checkout@v3  # GitHub 공식 액션 사용
      
      # ----------------------------------------
      # Step 2: 버전 정보 추출
      # 태그 push면 태그 이름(v2.1), 아니면 'latest'
      # ----------------------------------------
      - name: Get version
        id: version  # 다른 step에서 참조할 ID
        run: |
          # GITHUB_REF가 refs/tags/로 시작하는지 확인
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            # refs/tags/v2.1 → v2.1 추출
            VERSION=${GITHUB_REF#refs/tags/}
            # 출력 변수 설정 (다른 step에서 사용)
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "is_release=true" >> $GITHUB_OUTPUT
          else
            # 태그가 아니면 latest
            echo "version=latest" >> $GITHUB_OUTPUT
            echo "is_release=false" >> $GITHUB_OUTPUT
          fi
      
      # ----------------------------------------
      # Step 3: Docker Hub 로그인
      # GitHub Secrets에 저장된 인증 정보 사용
      # ----------------------------------------
      - name: Login to Docker Hub
        uses: docker/login-action@v2  # Docker 공식 로그인 액션
        with:
          # Settings → Secrets에 저장된 값 사용
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
      
      # ----------------------------------------
      # Step 4: Docker 이미지 빌드
      # 항상 latest 빌드, 릴리스면 버전 태그도 빌드
      # ----------------------------------------
      - name: Build Docker image
        run: |
          # latest 태그는 항상 빌드
          docker build -t nayatrei3/nayatrei-app:latest ./app
          
          # 릴리스(태그 push)인 경우에만 버전 태그 추가 빌드
          if [[ "${{ steps.version.outputs.is_release }}" == "true" ]]; then
            # 예: nayatrei3/nayatrei-app:v2.1
            docker build -t nayatrei3/nayatrei-app:${{ steps.version.outputs.version }} ./app
          fi
      
      # ----------------------------------------
      # Step 5: Docker Hub에 이미지 업로드
      # 빌드한 이미지들을 Docker Hub에 push
      # ----------------------------------------
      - name: Push to Docker Hub
        run: |
          # latest 태그는 항상 push
          docker push nayatrei3/nayatrei-app:latest
          
          # 릴리스인 경우에만 버전 태그도 push
          if [[ "${{ steps.version.outputs.is_release }}" == "true" ]]; then
            # 예: nayatrei3/nayatrei-app:v2.1
            docker push nayatrei3/nayatrei-app:${{ steps.version.outputs.version }}
          fi
      
      # ----------------------------------------
      # Step 6: 결과 출력 (로그에 표시)
      # 어떤 이미지가 업로드되었는지 확인용
      # ----------------------------------------
      - name: Image info
        run: |
          # latest는 항상 출력
          echo "Pushed: nayatrei3/nayatrei-app:latest"
          
          # 릴리스인 경우 버전 태그도 출력
          if [[ "${{ steps.version.outputs.is_release }}" == "true" ]]; then
            echo "Pushed: nayatrei3/nayatrei-app:${{ steps.version.outputs.version }}"
          fi

# ============================================
# 전체 흐름 요약:
# 1. main push → latest만 빌드/업로드
# 2. v2.1 tag push → latest + v2.1 빌드/업로드
# ============================================
```

- [깃허브 액션 문서](https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)

파일은 기본적으로 yaml형식으로 작성하며, 내용은 깃허브 액션에서 정의한 고유의 문법을 따른다.<br/>
정확히 무슨 기능인지는 모르지만 키워드를 보고 유추하기에는 충분하다.
> 모르면 그냥 느껴

<br/>

# CI/CD 자동화
---

## 태그 버전관리 자동화

개발자가 개발을 하게 되면 하루에도 몇 번씩 깃 저장소에 올릴 일이 생기는데,<br/>
그에 따라 생기는 모든 이미지를 도커 허브에 태그를 지정하여 올릴 필요는 없을 것이다.<br/>
특정 시점의 버전만 태그를 따서 올리면 충분하기에 매번 덮어씌워지는 마지막 이미지를 알리는 latest 태그와,<br/>
v2.1처럼 따로 넘버링해서 올리고 관리하는 태그 두 가지 방식으로 사용할 수 있게 워크 플로우 파일을 작성했었다.<br/> 
준비는 되었으니 이제 테스트를 해 보겠다.

<div align="left" style="display:flex;">
  <img src="assets/img/docker/github-actions_push.png" alt="깃 저장소 푸쉬" width="500">
  <img src="assets/img/docker/dockerhub_tag.png" alt="도커 저장소 푸쉬" width="500">
</div>
> daily update에 비해, weekly update는 태그를 생성하는 절차가 더 존재한다.

매일 하는 업데이트는 따로 버전 관리 없이 마지막 이미지만 저장하고,<br/>
주에 1번 하는 업데이트는 버전 명을 지정해서 따로 이미지를 저장하는 방식이다.<br/>

### 각 구문별 해석

- `git push origin main`
  - main 브랜치의 최신 상태를 GitHub에 업로드한다.
- `git tag v2.1`
  - 현재 커밋에 v2.1이라는 태그를 붙인다.
- `git push origin v2.1`
  - v2.1 태그를 GitHub에 업로드한다.

## 빌드 테스트 자동화

현재 상태에서는 깃에 푸쉬하면 자동으로 도커 허브 저장소까지 반영이 되는데,<br/>
빌드가 실패하는 잘못된 코드가 올라간다면 문제가 생길 것 이다.<br/>
물론 개발자가 애초에 깃에 빌드가 실패하는 코드를 올릴 경우는 거의 없겠지만,<br/>
로컬 환경과 운영 환경의 차이에서 오는 문제로 생길 가능성은 충분히 예측할 수 있다.<br/>
그러므로 혹시 모를 상황에 대비하여, 깃에 푸쉬가 되면 자동으로 빌드 테스트를 진행하고 
성공했을때만 도커 허브에 배포하는 기능을 추가해보겠다.<br/>

### 예상 실행 흐름

<div align="center">
  <img src="assets/img/docker/ci_cd_flow.png" alt="ci/cd 흐름" width="650">
</div>
> 선 빌드 테스트를 수행하여 성공했을 경우에만 빌드하여 도커 허브에 업로드를 한다.

- 핵심: 버그 있는 코드는 배포 하지 않는다.

### 테스트 파일 작성

성공/실패 케이스 파일을 따로 만드는게 테스트하기에 편하기에 테스트용 파일을 준비했다.

- 파이썬 앱(/docker_github-actions/app/test/test_app.py)

```python
# test/test_app.py
import pytest
import sys
import os

# app.py를 import할 수 있도록 경로 추가
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

from app import app

@pytest.fixture
def client():
    """Flask 테스트 클라이언트 생성"""
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

def test_home(client):
    """메인 페이지 테스트"""
    response = client.get('/')
    assert response.status_code == 200
    data = response.get_json()
    assert 'message' in data
    assert 'status' in data
    assert data['status'] == 'running'

def test_home_message_content(client):
    """메시지 내용 확인"""
    response = client.get('/')
    data = response.get_json()
    assert 'Hello' in data['message'] or 'CI/CD' in data['message']

def test_response_format(client):
    """응답 형식 검증"""
    response = client.get('/')
    assert response.content_type == 'application/json'
```

<br/>

- requirements.txt(/docker_github-actions/app/requirements.txt)

기존 파일에 파이썬 테스트 프레임워크 `pytest==7.4.3` 추가

<br/>

- \__init__.py(/docker_github-actions/app/test/\__init__.py)

test 디렉토리를 파이썬 패키지로 인식시키기 위한 빈 init 파일 생성

#### 빌드 테스트

```linux
pip install pytest

cd /docker_github-actions/app
pytest test/ -v
```

<div align="left">
  <img src="assets/img/docker/pytest.png" alt="pytest" width="500">
</div>
> 실행 전 pip install -r requirements.txt 명령어를 실행하여 패키지를 설치했다.

#### 워크플로우 파일에 빌드 테스트 추가

워크플로우(/docker_github-actions/.github/workflows/docker-build.yml)

```yml
# ============================================
# Workflow 이름 (GitHub Actions 탭에 표시됨)
# ============================================
name: Docker Build and Push

# ============================================
# 트리거: 언제 이 workflow를 실행할지 정의
# ============================================
on:
  push:
    branches: [ main ]  # main 브랜치에 push 시 실행
    tags:
      - 'v*'           # v로 시작하는 태그 push 시 실행 (예: v1.0, v2.1)

# ============================================
# Jobs: 실행할 작업들
# ============================================
jobs:
  # ============================================
  # Job 1: 테스트 실행 (새로 추가)
  # ============================================
  test:
    # Ubuntu 최신 버전 가상 머신에서 실행
    runs-on: ubuntu-latest
    
    steps:
      # 코드 가져오기
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Python 환경 설정 (새로 추가)
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      # 의존성 설치 (새로 추가)
      - name: Install dependencies
        run: |
          cd app
          pip install -r requirements.txt
      
      # 테스트 실행 (새로 추가)
      - name: Run tests
        run: |
          cd app
          pytest tests/ -v --tb=short
      
      # 테스트 결과 요약 (새로 추가)
      - name: Test summary
        if: always()
        run: |
          if [ $? -eq 0 ]; then
            echo "All tests passed!"
          else
            echo "Tests failed!"
            exit 1
          fi

  # ============================================
  # Job 2: Docker 빌드 & 배포
  # ============================================
  build:
    needs: test  # test job이 성공해야 실행 (추가됨)
    # Ubuntu 최신 버전 가상 머신에서 실행
    runs-on: ubuntu-latest
    
    # ============================================
    # Steps: 순차적으로 실행할 단계들
    # ============================================
    steps:
      # ----------------------------------------
      # Step 1: GitHub 저장소에서 코드 가져오기
      # ----------------------------------------
      - name: Checkout code
        uses: actions/checkout@v3  # GitHub 공식 액션 사용
      
      # ----------------------------------------
      # Step 2: 버전 정보 추출
      # 태그 push면 태그 이름(v2.1), 아니면 'latest'
      # ----------------------------------------
      - name: Get version
        id: version  # 다른 step에서 참조할 ID
        run: |
          # GITHUB_REF가 refs/tags/로 시작하는지 확인
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            # refs/tags/v2.1 → v2.1 추출
            VERSION=${GITHUB_REF#refs/tags/}
            # 출력 변수 설정 (다른 step에서 사용)
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "is_release=true" >> $GITHUB_OUTPUT
          else
            # 태그가 아니면 latest
            echo "version=latest" >> $GITHUB_OUTPUT
            echo "is_release=false" >> $GITHUB_OUTPUT
          fi
      
      # ----------------------------------------
      # Step 3: Docker Hub 로그인
      # GitHub Secrets에 저장된 인증 정보 사용
      # ----------------------------------------
      - name: Login to Docker Hub
        uses: docker/login-action@v2  # Docker 공식 로그인 액션
        with:
          # Settings → Secrets에 저장된 값 사용
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
      
      # ----------------------------------------
      # Step 4: Docker 이미지 빌드
      # 항상 latest 빌드, 릴리스면 버전 태그도 빌드
      # ----------------------------------------
      - name: Build Docker image
        run: |
          # latest 태그는 항상 빌드
          docker build -t nayatrei3/nayatrei-app:latest ./app
          
          # 릴리스(태그 push)인 경우에만 버전 태그 추가 빌드
          if [[ "${{ steps.version.outputs.is_release }}" == "true" ]]; then
            # 예: nayatrei3/nayatrei-app:v2.1
            docker build -t nayatrei3/nayatrei-app:${{ steps.version.outputs.version }} ./app
          fi
      
      # ----------------------------------------
      # Step 5: Docker Hub에 이미지 업로드
      # 빌드한 이미지들을 Docker Hub에 push
      # ----------------------------------------
      - name: Push to Docker Hub
        run: |
          # latest 태그는 항상 push
          docker push nayatrei3/nayatrei-app:latest
          
          # 릴리스인 경우에만 버전 태그도 push
          if [[ "${{ steps.version.outputs.is_release }}" == "true" ]]; then
            # 예: nayatrei3/nayatrei-app:v2.1
            docker push nayatrei3/nayatrei-app:${{ steps.version.outputs.version }}
          fi
      
      # ----------------------------------------
      # Step 6: 결과 출력 (로그에 표시)
      # 어떤 이미지가 업로드되었는지 확인용
      # ----------------------------------------
      - name: Image info
        run: |
          # latest는 항상 출력
          echo "Pushed: nayatrei3/nayatrei-app:latest"
          
          # 릴리스인 경우 버전 태그도 출력
          if [[ "${{ steps.version.outputs.is_release }}" == "true" ]]; then
            echo "Pushed: nayatrei3/nayatrei-app:${{ steps.version.outputs.version }}"
          fi

# ============================================
# 전체 흐름 요약:
# 1. main push → test 실행 → (성공) build 실행 (새로 추가)
# 2. v2.1 tag push → test 실행 → (성공) build 실행 (새로 추가)
# 3. 테스트 실패 시 → build 실행 안 됨 (새로 추가)
# ============================================
```
> 빌드 테스트 관련하여 새로 추가된 부분을 표시했다.

## push 테스트

수정 내역이 깃에 올라가면 먼저 빌드 테스트를 수행하여 성공시에만
도커 허브에 업로드하는 로직을 추가하였으니 정상 작동되는지 테스트를 해보겠다.

<div align="left" style="display:flex;">
  <img src="assets/img/docker/auto_build_test1.png" alt="auto_build_test1" width="500">
  <img src="assets/img/docker/auto_build_test2.png" alt="auto_build_test2" width="500">
</div>
> 깃 토큰에 workflow 권한을 추가해줘야 정상적으로 push가 가능해진다.

<div align="left" style="display:flex;">
  <img src="assets/img/docker/auto_build_test3.png" alt="auto_build_test3" width="500">
  <img src="assets/img/docker/auto_build_test4.png" alt="auto_build_test4" width="500">
</div>
> 깃허브 액션에서 먼저 테스트, 빌드를 성공적으로 수행 후 도커 허브에 이미지 업로드가 되었다.

### 빌드 실패 테스트

테스트용 파이썬 앱 파일(/docker_github-actions/app/test/test_app.py)의 맨 끝에 실패하는 테스트용 로직을 추가했다.

```python
def test_should_fail():
    """일부러 실패하는 테스트"""
    assert 1 == 2  # 무조건 실패!
```

<div align="left">
  <img src="assets/img/docker/build_fail_test.png" alt="build_fail_test" width="700">
</div>
> 깃허브 액션에서 빌드를 실패하니, 도커 허브에는 이미지 업로드가 되지 않았다.

